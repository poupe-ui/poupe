import { addTemplate, addVitePlugin } from '@nuxt/kit';
import tailwindPlugin from '@tailwindcss/vite';

import { contentGlobs } from '@poupe/vue/config';

import {
  type CSSProperties,

  formatCSSProperties,
  formatTheme,
  makeThemeFromPartialOptions,
  DEBUG,
} from './utils';

import type {
  SetupContext,
  TailwindPlugin,
  TailwindOptions,
} from './types';

const TAILWIND_CSS_FILENAME = 'tailwind.css';
const TAILWIND_CSS_ALIAS = '#poupe.css';

export const formatPlugin = (plugin: TailwindPlugin, indent: string = '  '): string[] => {
  if (typeof plugin === 'string') {
    return [`@plugin '${plugin}';`];
  }

  const [name, props] = plugin;
  const lines = formatCSSProperties(props);

  if (lines.length === 0)
    return [`@plugin '${name}';`];

  return [
    `@plugin '${name}' {`,
    ...lines.map(line => `${indent}${line};`),
    '}',
  ];
};

/** @returns a resolved and deduplicated list of sources to scan */
const prepareSources = (context: SetupContext): string[] => {
  const { resolve, options } = context;

  // resolve and make unique
  const sources = [
    ...contentGlobs(),

    // extra files to scan
    ...(options.tailwind?.sources || []).filter(source => source != '').map(source => resolve(source)),
  ];

  // reassemble. first-insert order preserved
  return [...new Set(sources)];
};

// TODO: move to @poupe/vue
const defaultTailwindPlugins: TailwindPlugin[] = [
  'tailwind-scrollbar',
];

/** @returns sanitized list of plugins to enable */
const preparePlugins = (options?: TailwindOptions): TailwindPlugin[] => {
  // filter out empty entries
  const plugins: TailwindPlugin[] = [
    ...defaultTailwindPlugins,
    ...options?.plugins || [],
  ].filter((plugin) => {
    if (typeof plugin === 'string') {
      return plugin !== '';
    }
    if (Array.isArray(plugin) && plugin.length == 2) {
      return plugin[0] !== '';
    }
    return false;
  });

  // make unique
  const pluginsMap: Map<string, CSSProperties | undefined> = new Map();
  for (const plugin of plugins) {
    if (typeof plugin === 'string') {
      pluginsMap.set(plugin, undefined);
    } else {
      pluginsMap.set(plugin[0], plugin[1]);
    }
  }

  // reassemble. first-insert order preserved
  return [...pluginsMap.entries()].map(([name, props]) => {
    if (props) {
      return [name, props];
    }
    return name;
  });
};

/** generate the content of the `tailwind.css` file */
const getCSSContent = <K extends string>(context: SetupContext<K>): string => {
  const { options } = context;

  const sources = prepareSources(context);
  const plugins = preparePlugins(options.tailwind);
  const theme = makeThemeFromPartialOptions(options.theme);

  // generate content for the `tailwind.css` file embedding
  // the poupe theme
  const lines: string[] = [
    '/* This file is generated by @poupe/nuxt. DO NOT EDIT */',
    '',
    '@import \'tailwindcss\';',
    '',
    // @theme
    formatTheme(theme).join(''),
    // @plugin
    ...(plugins ? [...plugins.flatMap(plugin => formatPlugin(plugin)), ''] : []),
    // @source
    ...(sources ? sources.map(path => `@source '${path}';`) : []),
  ];

  return lines.join('\n');
};

export const setupTailwind = async <K extends string>(context: SetupContext<K>) => {
  const { logger, nuxt } = context;
  const start = Date.now();

  if (DEBUG) logger.debug(`Generating \`${TAILWIND_CSS_FILENAME}\`...`);

  // template
  const cssFile = addTemplate({
    filename: TAILWIND_CSS_FILENAME,
    write: true,
    getContents: () => getCSSContent(context),
  });

  logger.success(`Poupe generated \`${DEBUG ? cssFile.dst : TAILWIND_CSS_ALIAS}\` in ${Date.now() - start}ms`);
  nuxt.options.alias[TAILWIND_CSS_ALIAS] = cssFile.dst;

  // vite plugin
  addVitePlugin(tailwindPlugin());

  // TODO: setup vite

  // inject CSS
  nuxt.options.css = nuxt.options.css || [];
  nuxt.options.css.unshift(cssFile.dst);
};
